#+TITLE: Re: Research
#+SUBTITLE: A publication template with reproducible research in mind.
#+SETUPFILE: ~/.config/emacs/modules/org.theme
#+OPTIONS: toc:1 ^:nil

* Motivation

This template aims to simplify the writing and sharing of
publications, in particular of those which contain many figures, tables,
or statistics derived from analysis data. I noticed that it commonly
occurred when I wrote a manuscript and placed the analysis numbers in
the text, the input data or the results slightly changed and required
to update the manuscript. This quickly lead to confusion: I was unsure whether
all numbers and figures were up-to-date, or even worse, where a
particular number came from exactly.

The solution is simple: the analysis code should not only create the
figures and compute the results, but also write them to ~LaTeX~
variables / files which I could input into the manuscript. This way,
the numbers are always up-to-date, and if I or anyone else has a doubt
about a specific number, I can look at the code which generated it
(rather than trying to retrace my own analysis months later).

This greatly simplifies writing and maintaining the manuscript, and
contributes towards reproducible research, provided that the scripts
(and, if possible, the data) are shared together with the
manuscript. This is possible for example on [[https://arxiv.org][arXiv]], where you can
upload a source archive.

In this template, there are a collection of scripts to bridge the gap
between ~python~ and ~LaTeX~. I further added small shell scripts for
compiling and cleaning the ~TeX~ directory, as well as creating source
~tar.gz~ archives which can later be sent to the publisher or uploaded
to [[https://arxiv.org][arXiv]]. These source archives automatically include only the files
relevant to the manuscript compilation.

Finally, I have added functions to create ~pgf~ figures with ~matplotlib~. 
These figures are created at compile time by ~LaTeX~ as vector graphics, giving
infinite resolution and using the same font as the rest of the manuscript.
The figures further are aware of the manuscript ~\textwdith~.

* Template Structure
#+TOC: headlines 1 local

** data/
#+TOC: headlines 3 local

Data required to create the figures and tables. This directory is not
included in the source ~tar.gz~ files which are meant to be submitted to arXiv or
the publisher.

Ideally, the data files stored here are reduced versions of the final
analysis results: small disk usage while retaining the necessary
information to reproduce the figures, tables, and numbers in the paper.

As an example, I'm adding a small ~csv~ file of the ~matplotlib~ release dates.

#+begin_src csv :tangle data/release_dates.csv
version,date
v2.2.4,2019-02-26
v3.0.3,2019-02-26
v3.0.2,2018-11-10
v3.0.1,2018-11-10
v3.0.0,2018-09-18
v2.2.3,2018-08-10
v2.2.2,2018-03-17
v2.2.1,2018-03-16
v2.2.0,2018-03-06
v2.1.2,2018-01-18
v2.1.1,2017-12-10
v2.1.0,2017-10-07
v2.0.2,2017-05-10
v2.0.1,2017-05-02
v2.0.0,2017-01-17
v1.5.3,2016-09-09
v1.5.2,2016-07-03
v1.5.1,2016-01-10
v1.5.0,2015-10-29
v1.4.3,2015-02-16
v1.4.2,2014-10-26
v1.4.1,2014-10-18
v1.4.0,2014-08-26
#+end_src

** scripts/

The ~python~ part of the template is in this directory. The scripts
create and compute the figures, tables, and numbers presented in the
article using the analysis results in the [[data/]] directory and store
them in the [[gfx/]], [[tables/]], and [[stats.tex][aux/stats.tex]] directories / file.

I will demonstrate this in a minimal working example using ~matplotlib~ release dates (see the [[data/]] directory), which I found [[https://matplotlib.org/stable/gallery/lines_bars_and_markers/timeline.html][here]].

*** figure_setup.py

This file handles the ~matplotlib~ default settings which
give the figures in the paper a uniform look. It could easily be
merged with the [[create_figures.py]] script, though I like to keep the
setup and the figure code separate.

Figures in the paper are saved in the [[https://ctan.org/pkg/pgf?lang=en][pgf]] "format". This is the
underlying ~TeX~ macros library of the famous [[https://texample.net/tikz/][TikZ]] package. The figures
are written as ~TeX~ commands to file by ~matplotlib~. The advantages are
outlined above, here I give the "drawback": very few lines of setup
are necessary first.

We start with some imports.

#+begin_src python :tangle scripts/figure_setup.py
import matplotlib
import numpy as np
#+end_src

Because our ~pgf~ graphics are drawn into the ~pdf~ document, we want to make sure that the
figure width matches the ~\textwidth~ in the document. ~matplotlib~ figure sizes are by default in inches. The ~textwidth~ is given in the ~TeX~ logfile:

#+begin_src bash
$ grep textwidth main.log
845:* \textwidth=522.0pt
#+end_src

It depends on the document style file *and will in general be different
between the preprint and the publisher version.* Remember to adapt this
value in the function below before recompiling the document and
submitting to a new destination.

We define a function which accepts a width in units of ~\textwidth~ and
the ratio of the figure width to the figure height, and returns the
corresponding figure size in inches. Note that axes labels, figure
titles, and other annotations outside the plotting area still count to
the figure area in ~matplotlib~ terms. Plotting a figure with equal
aspect ratio does hence not necessarily yield square axes. You can
find more information in [[https://stackoverflow.com/questions/36040605/matplotlibs-figure-and-axes-explanation][this StackOverflow post]].
Furthermore, don't forget to apply ~plt.tight_layout()~ before saving
the figure to remove padding around the figure.

The default aspect ratio (width:height) is the golden ratio.

#+begin_src python :tangle scripts/figure_setup.py
GOLDEN_RATIO = (np.sqrt(5) + 1) / 2 

def figsize(width=0.5, aspect=GOLDEN_RATIO):
    """Compute the figure width and height in inches.

    Parameters
    ==========
    width : float
        The figure width in units of the \textwidth. Default is 0.5,
        corresponding to one columnwidth.
    aspect : float
        The aspect ratio (width / height) of the figure. Default is the golden ratio.

    Returns
    =======
    tuple
        The figure width and height in inches.
    """
    TEXTWIDTH = 522  # in points, from the LaTeX document log file
    POINTS_TO_INCHES = 1 / 72.27

    figure_width = TEXTWIDTH * POINTS_TO_INCHES * width
    figure_height = figure_width / aspect

    return figure_width, figure_height
#+end_src

Now, we edit the ~matplotlib~ figure defaults to our liking by updating
the ~rcParams~ dictionary. You can find a list of the editable
configuration parameters [[https://matplotlib.org/stable/tutorials/introductory/customizing.html][here]]. 

The most important parameters below are the following:

- ~"backend" : "pgf"~ > Required to export figures to the ~pgf~ format
- ~"backend_fallback" : True~ > Sometimes, we still want to save as ~png~ or ~pdf~
- ~"text.usetex : True~ > Enable ~TeX~ support for figure labels, legends, ...
- ~"pgf.preamble":~ (string of ~TeX~ ~\usepackage~ commands) ~ > ~TeX~ packages which are required for the figure creation. Most importantly, fonts.
- ~"figure.figsize" : figsize(width=0.5)~ > Calling our custom figure size function. Now figures are by default one column wide.
- ~"font.family" : "serif"~ > ~matplotlib~ by default sets the figure font to sans-serif. If your manuscript uses a serif-font, this is the setting to set. Otherwise, comment this line.

#+begin_src python :tangle scripts/figure_setup.py
SETUP = {
    # ----------
    # GENERAL SET-UP
    "backend"              : "pgf",         # To export figures to .pgf
    "backend_fallback"     : True,          # If not compatible,
                                            #  mpl will find a compatible one
    "toolbar"              : "toolbar2",    # "toolbar2", "toolmanager", "None"
    "timezone"             : "UTC",         # a pytz timezone string,
                                            # eg US/Central or Europe/Paris

    # ----------
    # LaTeX SET-UP
    "text.usetex"          : True,          # use inline math for ticks
    "pgf.rcfonts"          : False,         # setup fonts from rc parameters

    # Packages required for figure compilation:
    "pgf.preamble":        
                    r"\usepackage{amsmath} "
                    r"\usepackage[utf8x]{inputenc} "
                    r"\usepackage[T1]{fontenc} "
                    r"\usepackage{txfonts} " # txfonts are used by A&A Journal
                    r"\usepackage[default]{sourcesanspro} "
                    r"\usepackage{pgfplots} "
                    r"\usepgfplotslibrary{external} "
                    r"\tikzexternalize "
                    r"\usepackage{xcolor} "
                    ,

    # ----------
    # GENERAL
    # ----------
    "figure.figsize"       : figsize(width=0.5),
    "savefig.dpi"          : 400,
    "font.size"            : 10, 
    "font.family"          : "serif",
    "text.color"           : "#000000",
    "axes.facecolor"       : "#ffffff",      # axes background color
    "axes.edgecolor"       : "#000000",       # axes edge color
    "axes.linewidth"       : 0.5,           # edge linewidth
    "axes.grid"            : False,         # display grid or not
    "axes.titlesize"       : "large",  # fontsize of the axes title
    "axes.labelsize"       : "small", # fontsize of the x any y labels
    "axes.labelcolor"      : "black",
    "axes.axisbelow"       : True,   # whether axis gridlines and ticks are
                                     # below the axes elements (lines, text)
    "axes.xmargin"         : 0,
    "axes.ymargin"         : 0,
    "axes.spines.top"      : True,
    "axes.spines.right"    : True,
    "xtick.major.size"     : 4,      # major tick size in points
    "xtick.minor.size"     : 2,      # minor tick size in points
    "xtick.major.pad"      : 2,      # distance to major tick label in points
    "xtick.major.width"    : 0.5,
    "xtick.minor.width"    : 0.3,
    "xtick.minor.visible"  : True,
    "xtick.minor.pad"      : 2,    # distance to the minor tick label in points
    "xtick.color"          : "black", # color of the tick labels
    "xtick.top"            : True,
    "xtick.labelsize"      : "8",  # fontsize of the tick labels
    "xtick.direction"      : "in",     # direction: in or out
    "ytick.major.size"     : 4,      # major tick size in points
    "ytick.major.width"    : 0.5,
    "ytick.minor.width"    : 0.2,
    "ytick.minor.size"     : 2,      # minor tick size in points
    "ytick.major.pad"      : 2,      # distance to major tick label in points
    "ytick.minor.pad"      : 2,   # distance to the minor tick label in points
    "ytick.major.width"    : 0.5,
    "ytick.minor.width"    : 0.3,
    "ytick.right"          : True,
    "ytick.color"          : "black", # color of the tick labels
    "ytick.labelsize"      : "8",  # fontsize of the tick labels
    "ytick.direction"      : "in",     # direction: in or out
    "ytick.minor.visible"  : True,
    "grid.color"           : "black", # grid color
    "grid.linestyle"       : ":",      # dotted
    "grid.linewidth"       : "0.2",    # in points
    "legend.fontsize"      : "small",
    "legend.fancybox"      : False,  # if True, use a rounded box for the
                                     # legend, else a rectangle
    "lines.linewidth"      : 1.0,           # line width in points
    "lines.antialiased"    : True,          # render lines in antialised

}
#+end_src

And finally, we apply these new default settings.

#+begin_src python :tangle scripts/figure_setup.py
matplotlib.rcParams.update(SETUP)
#+end_src

*** create_figures.py

This script creates the figures included in the paper. I write one function for each figure, and give the same name to the function, the figure filename, and the figure label in the ~LaTeX~ manuscript.

To avoid having to edit the script every time we want to (re)compile a figure or change the output format, we add a rudimentary command line argument support.
  
We start again with imports, note that we import the [[figure_setup.py]] script to apply our ~matplotlib~ defaults.

#+begin_src python :tangle scripts/create_figures.py
from datetime import datetime
import os
import sys

import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

import figure_setup as fs

PATH_GFX = os.path.join(os.path.dirname(__file__), '../gfx/')
#+end_src

Now we define functions, one for each figure. The code of the figures
is not relevant to this explanation.

Note that the figure created with the ~plt.subplots()~ command has a
default size of one column width thanks to the defaults set above. The
file format (e.g. ~pgf~, ~pdf~) is added as an argument of the function to
allow easy command-line access, implemented below.

#+begin_src python :tangle scripts/create_figures.py
def hlines_demo(FORMAT):
    """Plot a randomly chosen matplotlib example to illustrate the default
    plot layout.

    Example adapted from
    https://matplotlib.org/stable/gallery/lines_bars_and_markers/vline_hline_demo.html

    Parameters
    ==========
    FORMAT : str
        File format to save the figure in.
    """
    fig, ax = plt.subplots()

    # Fixing random state for reproducibility
    np.random.seed(19680801)

    t = np.arange(0.0, 5.0, 0.1)
    s = np.exp(-t) + np.sin(2 * np.pi * t) + 1
    nse = np.random.normal(0.0, 0.3, t.shape) * s

    ax.plot(t, s + nse, "^", c='black')
    ax.vlines(t, [0], s, color='black')
    # By using ``transform=ax.get_xaxis_transform()`` the y coordinates are scaled
    # such that 0 maps to the bottom of the axes and 1 to the top.
    ax.vlines([1, 2], 0, 1, transform=ax.get_xaxis_transform(), colors='r')
    ax.set(xlabel=("Time / s"), ylabel=("Triangles"))

    plt.tight_layout()
    fig.savefig(os.path.join(PATH_GFX, f"hlines_demo.{FORMAT}"))
#+end_src

Now I define two more functions: One which is square, to demonstrate
the aspect ratio in the manuscript, and one which is two columns
wide. The latter is based on the ~matplotlib~ release dates data in the
[[data/]] directory. From this could, it should be apparent that any
changes to the ~csv~ file in the [[data/]] directory would immediately
translate into the figure (which then translates into the manuscript).

#+begin_src python :tangle scripts/create_figures.py
def solution_space(FORMAT):
    """Plot solution space to demonstrate a square figure. This is an
    adapted matplotlib example, from

    https://matplotlib.org/stable/gallery/images_contours_and_fields/
    contours_in_optimization_demo.html

    Parameters
    ==========
    FORMAT : str
        File format to save the figure in.
    """
    fig, ax = plt.subplots(figsize=fs.figsize(aspect=1))

    # Set up survey vectors
    xvec = np.linspace(0.001, 4.0, 101)
    yvec = np.linspace(0.001, 4.0, 105)

    # Set up survey matrices.  Design disk loading and gear ratio.
    x1, x2 = np.meshgrid(xvec, yvec)

    # Evaluate some stuff to plot
    obj = x1**2 + x2**2 - 2*x1 - 2*x2 + 2
    g1 = -(3*x1 + x2 - 5.5)
    g2 = -(x1 + 2*x2 - 4.5)
    g3 = 0.8 + x1**-3 - x2

    cntr = ax.contour(x1, x2, obj, [0.01, 0.1, 0.5, 1, 2, 4, 8, 16],
                    colors='black')
    ax.clabel(cntr, fmt="%2.1f", use_clabeltext=True)

    cg1 = ax.contour(x1, x2, g1, [0], colors='sandybrown')
    cg2 = ax.contour(x1, x2, g2, [0], colors='orangered')
    cg3 = ax.contour(x1, x2, g3, [0], colors='mediumblue')

    ax.set(xlim=(0, 4), ylim=(0, 4), xlabel='x / AU', ylabel='y / AU')

    plt.tight_layout()
    fig.savefig(os.path.join(PATH_GFX, f"solution_space.{FORMAT}"))


def matplotlib_release_dates(FORMAT):
    """Plot matplotlib release dates to showcase a two-column figure.

    Example adapted from
    https://matplotlib.org/stable/gallery/lines_bars_and_markers/timeline.html

    Parameters
    ==========
    FORMAT : str
        File format to save the figure in.
    """
    fig, ax = plt.subplots(figsize=fs.figsize(width=1, aspect=2))

    # Read in the data
    data = pd.read_csv(os.path.join(PATH_GFX, "../data/release_dates.csv"))
    names = data.version
    dates = data.date

    # Convert date strings (e.g. 2014-10-18) to datetime
    dates = [datetime.strptime(d, "%Y-%m-%d") for d in dates]

    # Choose some nice levels
    levels = np.tile([-5, 5, -3, 3, -1, 1],
                    int(np.ceil(len(dates)/6)))[:len(dates)]

    ax.vlines(dates, 0, levels, color="tab:red")  # The vertical stems.
    ax.plot(dates, np.zeros_like(dates), "-o",
            color="k", markerfacecolor="w")  # Baseline and markers on it.

    # annotate lines
    for d, l, r in zip(dates, levels, names):
        ax.annotate(r, xy=(d, l),
                    xytext=(-3, np.sign(l)*3), textcoords="offset points",
                    horizontalalignment="right",
                    verticalalignment="bottom" if l > 0 else "top")

    # format xaxis with 4 month intervals
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=4))
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%b %Y"))
    plt.setp(ax.get_xticklabels(), rotation=30, ha="right")
    ax.yaxis.set_visible(False)

    plt.tight_layout()
    fig.savefig(os.path.join(PATH_GFX, f"matplotlib_release_dates.{FORMAT}"))
#+end_src

Now we add the command line logic. The idea is to have the figure name
as mandatory argument, the format is optional. If the script is called
with the ~--all~ flag, all figures are compiled.

#+begin_src bash
python create_figures.py example_figure
python create_figures.py example_figure --format pdf
python create_figures.py --all
#+end_src

We keep a dictionary associating the figure name and the function
which creates it. In principle, we could exploit that figure and
function share their names, though using a dictionary is a simple way
of implementing it.

#+begin_src python :tangle scripts/create_figures.py
if __name__ == "__main__":

    # figure_name : figure_function
    FIGURE_FUNCTIONS = {
        "hlines_demo": hlines_demo,
        "solution_space": solution_space,
        "matplotlib_release_dates": matplotlib_release_dates,
    }

#+end_src

Command-line arguments are accessible via the ~sys.argv~ list. We also
add help messages in case the script is called with an insufficient
amount of arguments. 
#+begin_src python :tangle scripts/create_figures.py
    if len(sys.argv) < 2:
        print("Provide a figure name to compile it. Choose from:")
        print(list(FIGURE_FUNCTIONS.keys()))
        sys.exit()

    # Get the format if it was specified on the command line
    if "--format" in sys.argv:
       idx = np.where(sys.argv == "--format")[0] + 1
       FORMAT = sys.argv[idx]
    else:
       FORMAT = "pgf"

    # Call the figure function
    if not "--all" in sys.argv:
        figure_name = sys.argv[1]
        FIGURE_FUNCTIONS[figure_name](FORMAT)
    else:
        for figure, function in FIGURE_FUNCTIONS.items():
            print(f"Compiling {figure}..")
            function(FORMAT)
#+end_src

*** compute_stats.py

Statistics refers to numbers which may be included in the text but are
derived from the data. An example would be a sample size, which may
change throughout the analysis and the editing of the manuscript. Here, I use the number
of ~matplotlib~ versions and the earliest and latest releases as examples. It should be
apparent from the code that if the [[data/]] changed (e.g. a new version
comes out while writing the article), so would the variables defined
here and printed in the manuscript.

#+begin_src python :tangle scripts/compute_stats.py
import os
import sys

import pandas as pd
#+end_src

I am not aware of any package which makes it easy to write ~python~
variables to ~LaTeX~ code, so I write my own helper function. The exact
value of the ~LaTeX~ variable depends on the ~python~ variable filetype:
integers have commas as thousands-separators, floats have two digits
after the dot, etc. This solution will likely not scale well (what if
I want my integer with a decimal place for some reason?) so it works
for the minimum working example here.

The ~\xspace~ command ensures that ~LaTeX~ adds a space after inserting
the variable value into the text.

#+begin_src python :tangle scripts/compute_stats.py
def write_variables_to_file(stats):
    """Write the variables to the aux/stats.tex file.

    Parameters
    ==========
    stats : dict
        Dictionary containing variable names as keys and their value and filetype as values.
        The LaTeX variable name cannot contain underscores.
    """
    PATH_STATS = os.path.join(os.path.dirname(__file__), "../aux/stats.tex")

    with open(PATH_STATS, "w") as file_:

        for name, value in stats.items():

            if "_" in name:
                print(f"'_' is not a valid character in TeX variable names. "
                    f"Removing them from {name}.")

            name = name.replace("_", "")

            value, type_ = value

            if type_ is int:
                file_.write(f'\\def\\{name}{{{value:,}\\xspace}}\n')
            elif type_ is float:
                file_.write(f'\\def\\{name}{{{value:.2f}\\xspace}}\n')
            elif type_ is str:
                file_.write(f'\\def\\{name}{{{value}\\xspace}}\n')

#+end_src

Now we define variables and write them to the file. Here, I add the number of ~matplotlib~ versions and the versions and dates of the earliest and latest releases.

#+begin_src python :tangle scripts/compute_stats.py
if __name__ == "__main__":

    # Directories and data
    PATH_DATA = os.path.join(os.path.dirname(__file__), "../data/")
    data = pd.read_csv(os.path.join(PATH_DATA, "release_dates.csv"))

    # Dictionary storing the variable : (value, type) pairs
    STATS = {}

    # Add the number of matplotlib versions
    STATS["NVersions"] = (len(data), int)

    # Get the earliest and latest version
    STATS["VersionEarliest"] = (data.version.min(), str) 
    STATS["VersionLatest"] = (data.version.max(), str) 
    STATS["VersionEarliestDate"] = (data.loc[
         data.version == data.version.min(), "date"
         ].values[0], str)
    STATS["VersionLatestDate"] = (data.loc[
         data.version == data.version.min(), "date"
         ].values[0], str)

    # And write to file
    write_variables_to_file(STATS)
    
#+end_src

As you can see, we are putting the code which computes the variable
value right next to the variable which we then place into the
manuscript. Later, this makes it easy for anyone to tell how a value was derived
in the analysis.

After running this file, the [[stats.tex]] file contains these lines:

#+begin_src 
\def\NVersions{23\xspace}
\def\VersionEarliest{v1.4.0\xspace}
\def\VersionLatest{v3.0.3\xspace}
\def\VersionEarliestDate{2014-08-26\xspace}
\def\VersionLatestDate{2014-08-26\xspace}
#+end_src

*** create_tables.py

This follows the same principle as [[compute_stats.py]]: we write the ~LaTeX~ code using ~python~.
Here, I write the matplotlib versions and release dates to a table. Since there are often more than one table in a document, I define helper functions for the table header and end.

#+begin_src python :tangle scripts/create_tables.py
import os
import sys

import pandas as pd
#+end_src

#+begin_src python :tangle scripts/create_tables.py
def table_header(columns):
    """Return table header string with specified columns.

    Parameters
    ==========
    columns : list of str
         List of column names.

    Returns
    =======
    str
         The tabular header with the appropriate number of columns set.
    """
    return \
        f"\\begin{{tabular}}{{{'l' + 'r' * (len(columns) - 1)}}}\n"\
        f"\t\\toprule\n"\
        f"\t{' & '.join(columns)} \\\\\n"\
        f"\t\\midrule\n"


def table_end():
    """Return table end string."""
    return \
        f"\t\\bottomrule\n"\
        f"\\end{{tabular}}\n"


def matplotlib_versions():
    """Write table of matplotlib versions to file."""
    path_table = os.path.join(os.path.dirname(__file__),
                              "../tables/matplotlib_versions.tex")

    path_data = os.path.join(os.path.dirname(__file__),
                              "../data/release_dates.csv")
    data = pd.read_csv(path_data)

    with open(path_table, "w") as table:

        table.write(table_header(["Version", "Date"]))

        # Ensure that the table data is sorted by date
        for _, row in data.sort_values("date").iterrows():

            version = row.version
            date = row.date

            table.write(f"{version} & {date}\\\\\n")

        table.write(table_end())
#+end_src

The command-line interface follows the same principles as the one in [[create_figures.py]].

#+begin_src python :tangle scripts/create_tables.py
if __name__ == "__main__":

    # table_name : table_function
    TABLE_FUNCTIONS = {
        "matplotlib_versions": matplotlib_versions,
    }

    if len(sys.argv) < 2:
        print("Provide a table name to compile it. Choose from:")
        print(list(TABLE_FUNCTIONS.keys()))
        sys.exit()

    # Call the figure function
    if not "--all" in sys.argv:
        table_name = sys.argv[1]
        TABLE_FUNCTIONS[table_name]()
    else:
        for table, function in TABLE_FUNCTIONS.items():
            print(f"Compiling {table}..")
            function()
#+end_src


** ./
#+TOC: headlines 3 local


*** main.tex

The root ~tex~ file of the template.
This file imports all other ~tex~ files and generates the pdf itself.

First, we define the destination of the article. When drafting the
manuscript, this will likely be a preprint server like
[[https://arxiv.org][arXiv]]. Publisher and preprint server likely use different
~documentclasses~ and require different ~LaTeX~ keywords to be
defined for e.g. the author affiliation. The customization is done in
this file.

The destination is set by using the corresponding ~make~ command, see [[Makefile]].

Disclaimer: My LaTeX skills are not [[https://www.thelocal.de/20190710/german-phrase-of-the-day-das-gelbe-vom-ei/][the yellow of the egg]].

#+begin_src tex :tangle main.tex
% Set destination of article: publisher,arxiv.
%
% Setting at compile time via eg 'pdflatex "\def\destination{arxiv} \input{main.tex}"'
% opentakes priority over the definition below
\ifx\destination\undefined
  \def\destination{arxiv}  % publisher,arxiv
\fi

\def\arxiv{arxiv}
\def\publisher{publisher}
#+end_src

The ~snapshot~ package creates a list of the dependencies of the
document version in the ~main.dep~ file. This list is later used when
creating the source ~tar.gz~ archives for submission.

#+begin_src tex :tangle main.tex
\RequirePackage{snapshot}
#+end_src

Pass options early to ~xcolor~ and ~hyperlink~ to avoid bugs when other
packages import them later.

#+begin_src tex :tangle main.tex
\PassOptionsToPackage{dvipsnames}{xcolor}
\PassOptionsToPackage{colorlinks=True,allcolors=RoyalBlue}{hyperlink}
#+end_src

Now, we define the documentclass. This definition largely depends on
the destination (publishers may provide their own ~LaTeX~ packages), so
we wrap it in an ~if~-block and define the document for each
destination.

I am a planetary scientist, so I use the Icarus journal as an example here.
Note that the [[preprint.sty][preprint]] style file is imported for the arXiv
submission. The preprint style uses a different command for the
affiliations as the Icarus (i.e. Elsevier) package, hence we mirror
the commands to do exactly the same.

#+begin_src tex :tangle main.tex
\ifx\destination\arxiv
  \documentclass{article}
  \pdfoutput=1	% ensure pdflatex when submitting to arXiv
  \usepackage{aux/preprint}
  \usepackage{natbib}
  \usepackage{authblk}
  % Alias author commands to mirror publisher
  \let\address\affil
\else
  \documentclass[preprint,3p,authoryear,lefttitle]{elsarticle}
  % \documentclass[preprint,5p,authoryear,twocolumn,lefttitle]{elsarticle}  % referee version
  \journal{Icarus}
\fi
#+end_src

Now we import useful packages. ~hyperref~ and ~cleverref~ should come last.

#+begin_src tex :tangle main.tex
\usepackage{amsmath}
\usepackage{aux/aas_macros}
\usepackage{graphicx}
\usepackage[title]{appendix}
\usepackage{booktabs}
\usepackage[skip=4pt]{caption}
\usepackage{here}
\usepackage[utf8]{inputenc}
\usepackage{lipsum}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{url}
\usepackage{xspace}
\usepackage[colorlinks=True, allcolors=RoyalBlue]{hyperref}
\usepackage[nameinlink]{cleveref}
#+end_src

Uncomment these two lines before submission to make the referee happy.

#+begin_src tex :tangle main.tex
% \usepackage{lineno}
% \linenumbers
#+end_src

Import our [[macros.tex][macros]] and [[stats.tex][statistics]] files.

#+begin_src tex :tangle main.tex
\input{aux/macros}
\input{aux/stats}
#+end_src

Finally, we are building the document itself. We start by adding a
title and information about the authors. Note the ~if~-block which defines additional
information like the email address of the leading author in case we
are submitting to the publisher.

#+begin_src tex :tangle main.tex
\begin{document}

% ------
\title{Re: Research - A publication template}

% Authors
\author[1]{Max Mahlke}

\ifx\destination\publisher
  \corref{cor}
  \cortext[cor]{Corresponding author}
  \ead{max.mahlke@oca.eu}  % email address of *most recent* author
\fi

% Affiliations
\address[1]{Universit{\'e}
  C{\^o}te d'Azur, Observatoire de la C{\^o}te d'Azur, CNRS, Laboratoire Lagrange, France}
#+end_src

Next comes the [[abstract.tex][abstract]]. Again, we wrap it in an ~if~-block to account for different preprint and publisher styles.

#+begin_src tex :tangle main.tex
\ifx\destination\arxiv
  \twocolumn[
    \begin{@twocolumnfalse}
      \maketitle
      \begin{abstract}
        \input{frontback/abstract}
      \end{abstract}
    \end{@twocolumnfalse}
  ]
\else
  \begin{frontmatter}
    \begin{abstract}
      \input{frontback/abstract}
    \end{abstract}
    \begin{keyword}
      Asteroids \sep Asteroids, Composition \sep Asteroids, Surfaces \sep Photometry
    \end{keyword}
  \end{frontmatter}
\fi
#+end_src

The heart of the article: the [[sections/][sections]].

#+begin_src tex :tangle main.tex
% Introction
\input{sections/section1}
% Methodology
\input{sections/section2}
% Results
\input{sections/section3}
% Discussion
\input{sections/section4}
#+end_src

Can't forget about the acknowledgements.

#+begin_src tex :tangle main.tex
\section*{Acknowledgements}%
\label{sec:acknowledgements}%
\input{frontback/ack}
#+end_src

Proper scientific work needs proper [[bib.bib][bibliographies]] [citation needed].
Another ~if~-block for the preprint vs publisher formats.

#+begin_src tex :tangle main.tex
\ifx\destination\arxiv
  \bibliographystyle{aux/arxiv}
\else
  \bibliographystyle{aux/publisher}
  \biboptions{authoryear}
\fi

\bibliography{aux/bib}
#+end_src

And we end the document with a fresh page and the [[appendix.tex][appendix]].

#+begin_src tex :tangle main.tex
\clearpage

% ------
% Appendix
\input{frontback/appendix}
\end{document}
#+end_src

*** Makefile

The ~Makefile~ offers convenient access to compile any part of the project. The command line call in the project root folder is

#+begin_src shell
$ make [command] 
#+end_src

where ~command~ is any of the following:

- ~doc~ > Recompile the article including bibliography and references
- ~bib~ > Recompile the ~main.bbl~ file using ~bibtex~
- ~latex~ > Recompile the ~main.pdf~ file using ~pdflatex~
- ~all~ > Recompile all figures, tables, statistics, and the article including bibliography and references
- ~clean~ > Delete auxiliary ~LaTeX~ files created during the compilation process
- ~publisher~ > Create a ~tar.gz~ file containing all relevant article files for submission to the publisher
- ~arxiv~ > Create a ~tar.gz~ file containing all relevant article files for submission to [[https://arxiv.org][arXiv]] 

In 90\% of the cases, you want to run ~make doc~}. 9\% are ~make clean~ to get
rid of the temporary files created during the ~LaTeX~ compilation process. At the very end, run ~make arxiv~ and ~make publisher~ to prepare the submission process. These two commands run the [[package.sh]] script.

#+begin_src shell :tangle Makefile
doc:
	@# compile main.tex with bibliography support
	make latex && make bib && make latex

latex:
	@# run latex on main.tex
	pdflatex main.tex

bib:
	@# compile bibliography
	bibtex main

clean:
	@# clean latex and bibtex auxiliary files
	@rm -f main.bbl main.aux main.nav main.out main.dvi main.snm main.toc main.blg
  @rm -f main.log main.fdb_latexmk main.fls main.dep main.synctex.gz main.vimtex.pdf

publisher:
	@# Create tar.gz to send to publisher
	sh package.sh publisher

arxiv:
	@# Create tar.gz for arxiv submission
	sh package.sh arxiv

all:
	@# Re-compile figures, tables, statistics, and the document
	python scripts/compute_stats.py
	python scripts/create_figures.py --all
	python scripts/create_tables.py --all
	make latex && make bib && make latex
#+end_src


*** package.sh

This ~shell~ script creates a ~tar.gz~ source archive for submission to
the publisher or [[https://arxiv.org][arXiv]]. A neat feature is that only files relevant for
the current version of the document are included in the archives:
stale files (such as figures which are no longer included) are
automatically left out.

#+begin_src shell :tangle package.sh
#!/usr/bin/env bash

# Compile if necessary, passing the destination parameter
read -p "Compile first? [y/n] " -n 1 REPLY 
echo 

if [[ "$REPLY" =~ ^[Yy]$ ]]; then
    make clean
    pdflatex "\def\destination{$1} \input{main.tex}"
    bibtex main
    pdflatex "\def\destination{$1} \input{main.tex}"
fi

make clean

echo
echo "Packing"
echo "-------"

# Create archive with files outside of dependency list
tar cfv $1.tar aux/aas_macros.sty

# Parse dependencies list for files to include
sort -u main.dep | grep "file.*{0000/00/00 v0.0}$" | while read -r line; do

    # Get the dependency filename
    filename=$(echo $line | cut -d'{' -f3 | cut -d'}' -f1)

    # Publisher probably wants the bib file too
    if [[ $filename == 'aux/publisher.bst' ]]; then
        tar --append -v -f $1.tar aux/bib.bib
    fi

    # Check if file exists
    if [[ -f $filename ]]; then 
        tar --append -v -f $1.tar $filename
    else
        # Otherwise, add .tex extension and try again
        filename="${filename}.tex"

        if [[ -f $filename ]]; then 
            tar --append -v -f $1.tar $filename
        fi
    fi

done

# arXiv does not want the bib, but it needs the style file
if [[ $1 == "arxiv" ]]; then
    tar --append -v -f $1.tar aux/preprint.sty
fi
#+end_src


*** template.org

The file you are currently reading unless you are reading the [[template.html][HTML]] file.

*** template.html

The file you are currently reading unless you are reading the [[template.org][org]] file.

** sections/
#+TOC: headlines 3 local

Where it all comes together.

The section files contain the actual content of the publication. Here, they are used to showcase the ~python~ - ~LaTeX~ interaction.

*** Introduction

Compiling multi-file documents requires specifying the root ~tex~ file
in all other files. This is achieved here for [[https://www.vim.org][vim]].

#+begin_src tex :tangle sections/section1.tex
%! TEX root = ../main.tex
#+end_src

A few lines of introduction. Notice the use of the ~LaTeX~ variables defined with the [[compute_stats.py]] script.

#+begin_src tex :tangle sections/section1.tex
\section{Introduction}%
\label{sec:introduction}%

This document highlights some aspects of the \textsc{Re: Research}
template.\footnote{\url{http://github.com/maxmahlke/re-research/}}
More information can be found in the \textsc{template.html} file in
the reference repository. I developed this template while writing a
publication myself \citep{2009.05129v1}.\footnote{\url{https://arxiv.org/pdf/2009.05129.pdf}}

The sample date are the release versions and date of the \textsc{matplotlib} package.
\textsc{matplotlib} has had \NVersions version, the earliest (version \VersionEarliest) in
\VersionEarliestDate, the latest (version \VersionLatest) in
\VersionLatestDate, refer to \Cref{tab:matplotlib_versions}.
#+end_src

At the end, we add the root ~tex~ file variable for [[https://www.gnu.org/software/emacs/][GNU Emacs]].

#+begin_src tex :tangle sections/section1.tex
%% Local Variables:
%% tex-main-file: "../main.tex"
%% End:
#+end_src

*** Methodology

#+begin_src tex :tangle sections/section2.tex 
%! TEX root = ../main.tex
#+end_src

#+begin_src tex :tangle sections/section2.tex 
\section{Methodology}%
\label{sec:methodology}%

All figures, tables, and numbers in the manuscript which are subject
to change when the analysis data changes are computed using
\textsc{python} script and saved into auxilliary \LaTeX files. This
document illustrates the use of these variables (such as in the
sentence on the versions of \textsc{matplotlib} above) as well as the
figure layout options.
The necessary files are created with comments via the
\textsc{template.org} file in the GitHub repository. More information
on the usage can be found there.

\Cref{fig:hlines_demo} showcases the default figure
layout. This is a \textsc{pgf} figure, meaning that it is written in
\LaTeX commands and created at document compile time. Notice the
infinite resolution thanks to vector graphics and that the font in the
figure matches the one used in the rest of the document. The figure
spans exactly one column.

In \Cref{fig:matplotlib_release_dates}, we can see the use of a double-column \textsc{pgf} figure.
\Cref{fig:solution_space} shows a square figure. See the
documentation for implementation details.

The supplied \textsc{Makefile} contains some convenience functions for
compiling and sharing the document. 

The rest of this document is padded with Lorem Impsum.

\lipsum
#+end_src

Include the ~matplotlib~ versions table created with [[create_tables.py]].

#+begin_src tex :tangle sections/section2.tex
\begin{table}[t]
\caption{An automatically generated table of \textsc{matplotlib} versions.}
\label{tab:matplotlib_versions}
\input{tables/matplotlib_versions.tex}
\end{table}
\lipsum[3-5]
#+end_src

#+begin_src tex :tangle sections/section2.tex 
%% Local Variables:
%% tex-main-file: "../main.tex"
%% End:
#+end_src

*** Results

#+begin_src tex :tangle sections/section3.tex
%! TEX root = ../main.tex
#+end_src

#+begin_src tex :tangle sections/section3.tex
\section{Results}%
\label{sec:results}%
\lipsum[3-5]
#+end_src

#+begin_src tex :tangle sections/section3.tex
\begin{figure}[t]
  \input{gfx/hlines_demo.pgf}
  \caption{Demo figure illustrating the default figure layout:
  colum-wide with a golden aspect ratio.}
  \label{fig:hlines_demo}
\end{figure}
\lipsum[3-8]
#+end_src

#+begin_src tex :tangle sections/section3.tex
\begin{figure*}[t]
  \input{gfx/matplotlib_release_dates.pgf}
  \caption{Example to illustrate the double-column figure layout, as
  well as the connection between raw data and the manuscript: Editing
  any line in the matplotlib release data directly translates into
  this figure after invoking the appropriate \textsc{make} command.}
  \label{fig:matplotlib_release_dates}
\end{figure*}

\lipsum[1-10]
#+end_src

#+begin_src tex :tangle sections/section3.tex
\begin{figure}[t]
  \input{gfx/solution_space.pgf}
  \caption{A figure with an aspect ratio of 1. Note that for
  \textsc{matplotlib}, the figure area includes the axes labels and
  annotations, hence the axes are not necessarily square even with
  equal aspect ratio.}
  \label{fig:solution_space}
\end{figure}
#+end_src

#+begin_src tex :tangle sections/section3.tex
%% Local Variables:
%% tex-main-file: "../main.tex"
%% End:
#+end_src

*** Discussion

#+begin_src tex :tangle sections/section4.tex
%! TEX root = ../main.tex
#+end_src

#+begin_src tex :tangle sections/section4.tex
\section{Discussion}%
\label{sec:discussion}%
\lipsum[3-4]
#+end_src

#+begin_src tex :tangle sections/section4.tex
%% Local Variables:
%% tex-main-file: "../main.tex"
%% End:
#+end_src


** frontback/
#+TOC: headlines 3 local

*** abstract.tex

The text to be inserted as abstract. It is wrapped in the correct
environment when put into the [[main.tex][root file]].

#+begin_src tex :tangle frontback/abstract.tex
The \textsc{Re: Research} publication template is meant to simplify
the writing of scientific manuscripts by creating a link between the
data analysis, done with the \textsc{python} programming language, and
the manuscript creation, built around the \LaTeX\xspace files. The premise is
that any figure, table, or number given in the manuscript which is
derived from your data should be placed in the manuscript by your
code. This removes the necessity of keeping the manuscript up-to-date
with changes in the input data. An additional bonus is an increase of
reproducible research: by publishing the scripts which compute the
manuscript content, anyone (including the original author) can verify
its derivation.
The template further provides a complete setup of \textsc{pgf}
integration for figure creation with the \textsc{matplotlib} package,
which allows to create vectorized figures utilizing the same font as
the rest of the document.
#+end_src

*** ack.tex

Again, this file only contains the actual text of the acknowledgements, the formatting is handled in the [[main.tex][root file]].

#+begin_src tex :tangle frontback/ack.tex
Many ideas I had have been improved and implemented thanks to StackOverflow discussion.
#+end_src

*** appendix.tex

One or more sections for the abstract.

#+begin_src tex :tangle frontback/appendix.tex
%%\appendix
%%\section{Implemented \textsc{make} commands}%
%%\label{app:implemented_make_commands}%
#+end_src

** aux/
#+TOC: headlines 3 local

*** macros.tex

Here, I define ~LaTeX~ macros which I commonly use. They are inserted into the [[main.tex][root file]] before the ~\begin{document}~ call.

#+begin_src tex :tangle aux/macros.tex
\newcommand{\abbr}[2]{\textit{#1} (#2)}  % Abbreviations

\newcommand{\wording}[1]{\textcolor{red}{#1}}
\newcommand{\source}{\textcolor{orange}{[citation needed]}}

\newcommand{\ie}{i.e.\,}
\newcommand{\eg}{e.g.\,}
#+end_src

Colormaps (and colorbars) in ~pgf~ plots are rasterized by default and saved as auxilliary ~png~ file. The pgf figure will contain lines like the following:

#+begin_src tex :tangle aux/macros.tex
\pgftext[left,bottom]{\includegraphics[interpolate=true,width=0.7381in,height=0.7381in]{figure-img0.png}}%
#+end_src

The rasterized png colormaps are created in the same directory as the
pgf file and added automatically. However, when using a specific
directory for your figures in your publication directory (such as the
~gfx/~ directory in this template), the ~\includegraphics~ command in the
pgf figure will fail.  Here is a workaround function I found on
StackOverflow (have not been able to track down the source):

#+begin_src tex :tangle aux/macros.tex
\newcommand\inputpgf[2]{{
\let\includegraphicsWithoutPath\includegraphics
\renewcommand{\includegraphics}[2][]{\includegraphicsWithoutPath[##1]{#1/##2}}
\input{#1/#2}
}}
#+end_src

The TeX commands to input the pgf figure now look like this:

#+begin_src tex
\begin{figure}[t]
  \centering
  \inputpgf{gfx}{great_figure.pgf}
  \caption{Look at my great figure with a nice colormap.}
  \label{fig:great_figure}
\end{figure}
#+end_src

The line below fixes an issue when using ~matplotlib~ generated ~pgf~ figures and
the ~inputenc~ ~LaTeX~ package.

#+begin_src tex :tangle aux/macros.tex
\DeclareUnicodeCharacter{2212}{-}
#+end_src

*** stats.tex

The numbers and statistics ~LaTeX~ variables computed with the [[compute_stats.py]] script.

*** preprint.sty

A preprint style file using in the compilation process when the destination is [[https://arxiv.org][arXiv]]. I have it from [[https://github.com/Swanson-Hysell/preprint-template.tex][this GitHub repository]], with only minor edits from my side.

*** bib.bib

The bibliography file of the article. Replace with your own.

*** arxiv.bst

A bibliography style file based on APJ. I have edited it to make the
page and journal numbers in the bibliography clickable links to the
DOI.

*** publisher.bst

The bibliography style file of the publisher. Replace as you see fit.

** gfx/
#+TOC: headlines 3 local

Output directory for the created figures.

** tables/
#+TOC: headlines 3 local

Output directory for the created tables.


* Troubleshooting

** ~pgf~ and rasterized elements - file not found error

See the ~\inputpgf~ command in the [[macros.tex]].

** Busy figures - TeX capacity exceeded

Busy figures (eg. a scatter plot with several thousand points) can exceed the TeX capacity during compilation and lead
to large rendering times of the pdf. I find it best to rasterize them.

#+begin_src python
scatter_plot = ax.scatter(..., rasterized=True)
#+end_src

Note that only the scatter-plot symbols are rasterized, the rest of the graphic are still crispy vectors.

